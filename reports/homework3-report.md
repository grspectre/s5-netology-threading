# Отчёт по сравнению производительности stream() и parallelStream() в Java

Дата проведения эксперимента: 2025-09-19
Среда выполнения:
- Java: Amazon Corretto 21.0.8
- ОС: Windows 11
- CPU/Ядра: AMD Ryzen 5 5600H, 6C/12T
- RAM: 16 GB
- Проект: Spring Boot (CommandLineRunner)

## Цель
Оценить и сравнить время выполнения типичного конвейера обработки данных (фильтрация → преобразование → агрегация) для последовательного потока `stream()` и параллельного потока `parallelStream()` на списке из 1_000_000 случайных чисел. Сформулировать рекомендации, когда целесообразно использовать параллельный поток.

## Описание задания и подход
- Сгенерирован список из 1_000_000 случайных целых чисел с помощью `ThreadLocalRandom`.
- Выполнены операции:
    - Фильтрация: отбор только чётных чисел `(x & 1) == 0`.
    - Преобразование: умножение каждого отфильтрованного числа на 2, с приведением к long.
    - Агрегация: суммирование всех значений.
- Реализованы два варианта конвейера:
    - Последовательный: `data.stream()`.
    - Параллельный: `data.parallelStream()`.
- Измерение времени: `System.nanoTime()` до и после выполнения, перевод в миллисекунды.
- Выполнен короткий «прогрев» (несколько прогонов) для снижения эффекта холодного старта JIT.
- Программа оформлена как Spring Boot приложение, логика — в `CommandLineRunner`.

## Код (фрагмент)
Основная логика измерений (из предоставленного кода):
```java
Result seq = measure("Sequential stream", () -> data.stream()
        .filter(x -> (x & 1) == 0)
        .mapToLong(x -> (long) x * 2)
        .sum());

Result par = measure("Parallel stream", () -> data.parallelStream()
        .filter(x -> (x & 1) == 0)
        .mapToLong(x -> (long) x * 2)
        .sum());
```

## Фактические результаты (из вывода программы)
- Входные данные:
    - Размер списка: 1 000 000
- Время и суммы:
    - [Sequential stream] Сумма: 499 422 086 336; Время: 23 мс
    - [Parallel stream]  Сумма: 499 422 086 336; Время: 7 мс
- Итог:
    - Суммы совпадают (корректность подтверждена).
    - Ускорение (parallel к stream): x3.29

Примечание: ускорение рассчитано как отношение времени последовательного варианта к параллельному: 23 мс / 7 мс ≈ 3.29.

## Анализ причин различий в производительности
Почему `parallelStream()` оказался быстрее на ~3.3 раза в данном эксперименте:
- Распараллеливание: параллельный поток распределяет работу по нескольким потокам из ForkJoinPool (обычно число потоков соответствует числу доступных ядер/аппаратных потоков). При объёме в 1 млн элементов конвейер фильтрации/преобразования/суммирования даёт достаточный объём вычислений, чтобы окупить накладные расходы на разбиение и слияние.
- Природа операций: операции чистые (без побочных эффектов), ассоциативная агрегация (sum), отсутствие синхронизаций и блокирующего I/O — это идеальный профиль для параллельной обработки.
- Примитивные стримы в середине конвейера: `mapToLong(...).sum()` снижает автобоксинг/распаковку в части агрегации и уменьшает нагрузку на GC.
- Аппаратная конфигурация: на системе с несколькими ядрами параллельный пул может действительно исполнять работу одновременно, что и приводит к заметному выигрышу.

Когда параллелизм может не помочь или замедлить:
- Малый объём данных или крайне лёгкие операции — накладные расходы parallel могут превысить полезную работу.
- Неудачная локальность данных, давление на память и кэш — промахи кэша могут съесть прирост.
- Наличие синхронизаций, доступа к общему состоянию, I/O — ограничивают параллелизм.

## Рекомендации: когда использовать parallelStream, а когда stream
Использовать parallelStream, если:
- Данных много (сотни тысяч/миллионы элементов).
- Операции CPU-интенсивные или умеренно затратные, чистые и легко редуцируемые (sum, max, count).
- Порядок не критичен или вы используете ассоциативные операции.
- Система располагает несколькими ядрами и не перегружена.

Оставаться на stream, если:
- Небольшие объёмы или микролёгкие операции.
- Есть побочные эффекты, общие изменяемые структуры, блокирующий I/O.
- Строгая стабильная упорядоченность критична.
- Профиль нагрузки «узкий по памяти» и распараллеливание ухудшает локальность.

## Проверка чек-листа
- Создан список из 1_000_000 случайных чисел — да.
- Выполнены фильтрация, преобразование, агрегация через stream() и parallelStream() — да.
- Измерено время выполнения обеих операций — да.
- Выведены результаты и проведён анализ причин различий — да.
- Составлен отчёт с описанием этапов — да.
- Ссылка на отчёт прикреплена в личном кабинете — https://github.com/grspectre/s5-netology-threading/blob/main/reports/homework3-report.md.

## Дополнительные замечания по качеству замеров
- Для повышенной надёжности можно:
    - Делать несколько итераций измерений и брать медиану/среднее.
    - Фиксировать JVM-флаги и версию.
    - Указывать характеристики CPU/планировщик ОС, текущую загрузку системы.
    - Сравнить с примитивными потоками от генератора: `IntStream.generate(...).limit(N)`, чтобы убрать автобоксинг списка.
    - Протестировать разные размеры N и разные сложности преобразований.

## Выводы
- На данном наборе данных и операциях параллельные потоки демонстрируют ускорение примерно x3.3 по сравнению с последовательными.
- Причина ускорения — эффективная загрузка нескольких ядер и отсутствие синхронизаций/побочных эффектов в конвейере.
- Параллельные потоки целесообразны для больших объёмов и CPU-интенсивных чистых вычислений; для малых объёмов или при наличии I/O/синхронизаций выгоднее последовательный поток.

Готов к добавлению ваших фактических параметров среды и ссылки на отчёт в личном кабинете. Если нужно, могу подготовить краткую версию отчёта для прикрепления на платформе или таблицу с несколькими повторными замерами.